fe model은 클래스로 짜지 않고 타입으로만 작성하는 이유는 뭐야

이 질문까지 왔으면 거의 아키텍처 핵심부를 정확히 짚고 있는 거야 👍
결론부터 말하면:

FE model을 클래스로 만들지 않고 타입(type/interface)으로만 두는 이유는
“상태를 가지는 객체”가 아니라 “데이터 스냅샷”으로 취급하기 위해서다.

아래에서 이유를 하나씩 풀어볼게.

1) FE model의 본질은 “행동”이 아니라 “형태”다

클래스를 쓰는 순간, 그 객체는 보통:

생성자

메서드

내부 상태

불변성/가변성 정책

을 갖기 시작해.

그런데 FE model은 대부분:

서버에서 받아온 데이터

React Query 캐시에 저장되는 값

UI 렌더링의 재료

즉:

“객체”라기보다 “데이터 구조”에 가깝다.

그래서 타입이 더 어울림.

2) React Query / 상태 관리와 클래스는 궁합이 안 좋다
1) 직렬화/복사 문제

React Query 캐시는:

JSON-like plain object를 전제로 함

equality 비교, 구조적 공유에 의존

클래스 인스턴스를 넣으면:

메서드는 직렬화 불가

hydration/SSR에서 깨질 수 있음

예상 못 한 reference 비교 버그 발생

2) 캐시 갱신 시 “객체 정체성”이 깨진다

React Query는 refetch 시:

새 객체를 만들어서 교체함

클래스 기반이면:

생성자/불변식/초기화 로직이 매번 재실행

의도치 않은 side effect 가능

3) FE model은 “불변 데이터”로 다루는 게 맞다

클래스는 자연스럽게 이런 유혹을 만든다:

book.rename("new title")
book.toggleFavorite()


하지만 React 패턴에서는:

이런 변경은 mutation을 통해

서버 or store를 통해

새 객체를 만들어서 교체해야 함

즉:

FE model은 “행동 주체”가 아니다.

행동은:

mutation hook

service

handler

에 있어야 함.

4) 타입은 tree-shaking, 번들, 성능 면에서도 유리

TypeScript 타입은:

빌드 타임에만 존재

JS 번들에 포함되지 않음

런타임 비용 0

클래스는:

런타임 코드

번들 사이즈 증가

메서드가 많을수록 비용 증가

특히 모델이 많아질수록 차이가 누적됨.

5) FE model에 “도메인 로직”을 넣고 싶다면 더 위험해짐

가끔 이런 욕구가 생김:

“Book.canEdit(user)” 같은 걸 모델에 넣고 싶다

이걸 클래스에 넣으면:

user context 필요

권한/정책 로직이 데이터 객체에 침투

테스트도 애매해짐

이런 로직은:

selector

service

util 함수

로 빼는 게 훨씬 깨끗함.

6) 타입 + 함수 조합이 더 유연하다

클래스 대신:

type Book = { ... }

function canEditBook(book: Book, user: User) {}
function getBookDisplayTitle(book: Book) {}


이 방식의 장점:

tree-shaking 잘 됨

테스트 쉬움

필요한 곳에서만 import

조합성이 좋음

7) “그럼 클래스는 언제 쓰냐?”
FE에서 클래스를 써도 괜찮은 경우는 아주 제한적

진짜 상태 머신

복잡한 계산 엔진

캔버스/3D 객체 래퍼

WebSocket client

외부 라이브러리 wrapper

👉 즉 “행동 + 상태 + 수명”이 명확한 경우

요약 테이블
기준	타입 기반 FE model	클래스 기반 FE model
React Query 캐시	✅ 최적	❌ 위험
불변성	✅ 자연스러움	⚠️ 유혹 많음
런타임 비용	✅ 0	❌ 있음
테스트	✅ 쉬움	⚠️ 번거로움
UI 친화성	✅ 높음	❌ 낮음
한 줄 결론

FE model은 “객체”가 아니라 “데이터 스냅샷”이다.
그래서 클래스가 아니라 타입이 가장 잘 맞는다.
