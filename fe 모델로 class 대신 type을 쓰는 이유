fe model은 클래스로 짜지 않고 타입으로만 작성하는 이유는 뭐야

이 질문까지 왔으면 거의 아키텍처 핵심부를 정확히 짚고 있는 거야 👍
결론부터 말하면:

FE model을 클래스로 만들지 않고 타입(type/interface)으로만 두는 이유는
“상태를 가지는 객체”가 아니라 “데이터 스냅샷”으로 취급하기 위해서다.

아래에서 이유를 하나씩 풀어볼게.

1) FE model의 본질은 “행동”이 아니라 “형태”다

클래스를 쓰는 순간, 그 객체는 보통:

생성자

메서드

내부 상태

불변성/가변성 정책

을 갖기 시작해.

그런데 FE model은 대부분:

서버에서 받아온 데이터

React Query 캐시에 저장되는 값

UI 렌더링의 재료

즉:

“객체”라기보다 “데이터 구조”에 가깝다.

그래서 타입이 더 어울림.

2) React Query / 상태 관리와 클래스는 궁합이 안 좋다
1) 직렬화/복사 문제

React Query 캐시는:

JSON-like plain object를 전제로 함

equality 비교, 구조적 공유에 의존

클래스 인스턴스를 넣으면:

메서드는 직렬화 불가

hydration/SSR에서 깨질 수 있음

예상 못 한 reference 비교 버그 발생

2) 캐시 갱신 시 “객체 정체성”이 깨진다

React Query는 refetch 시:

새 객체를 만들어서 교체함

클래스 기반이면:

생성자/불변식/초기화 로직이 매번 재실행

의도치 않은 side effect 가능

3) FE model은 “불변 데이터”로 다루는 게 맞다

클래스는 자연스럽게 이런 유혹을 만든다:

book.rename("new title")
book.toggleFavorite()


하지만 React 패턴에서는:

이런 변경은 mutation을 통해

서버 or store를 통해

새 객체를 만들어서 교체해야 함

즉:

FE model은 “행동 주체”가 아니다.

행동은:

mutation hook

service

handler

에 있어야 함.

4) 타입은 tree-shaking, 번들, 성능 면에서도 유리

TypeScript 타입은:

빌드 타임에만 존재

JS 번들에 포함되지 않음

런타임 비용 0

클래스는:

런타임 코드

번들 사이즈 증가

메서드가 많을수록 비용 증가

특히 모델이 많아질수록 차이가 누적됨.

5) FE model에 “도메인 로직”을 넣고 싶다면 더 위험해짐

가끔 이런 욕구가 생김:

“Book.canEdit(user)” 같은 걸 모델에 넣고 싶다

이걸 클래스에 넣으면:

user context 필요

권한/정책 로직이 데이터 객체에 침투

테스트도 애매해짐

이런 로직은:

selector

service

util 함수

로 빼는 게 훨씬 깨끗함.

6) 타입 + 함수 조합이 더 유연하다

클래스 대신:

type Book = { ... }

function canEditBook(book: Book, user: User) {}
function getBookDisplayTitle(book: Book) {}


이 방식의 장점:

tree-shaking 잘 됨

테스트 쉬움

필요한 곳에서만 import

조합성이 좋음

7) “그럼 클래스는 언제 쓰냐?”
FE에서 클래스를 써도 괜찮은 경우는 아주 제한적

진짜 상태 머신

복잡한 계산 엔진

캔버스/3D 객체 래퍼

WebSocket client

외부 라이브러리 wrapper

👉 즉 “행동 + 상태 + 수명”이 명확한 경우

요약 테이블
기준	타입 기반 FE model	클래스 기반 FE model
React Query 캐시	✅ 최적	❌ 위험
불변성	✅ 자연스러움	⚠️ 유혹 많음
런타임 비용	✅ 0	❌ 있음
테스트	✅ 쉬움	⚠️ 번거로움
UI 친화성	✅ 높음	❌ 낮음
한 줄 결론

FE model은 “객체”가 아니라 “데이터 스냅샷”이다.
그래서 클래스가 아니라 타입이 가장 잘 맞는다.

fe domain model class vs type

1) 가장 큰 차이: TypeScript의 “type”은 런타임에 없다

웹에서 type Book = {...} 는 빌드하면 완전히 사라져.
즉 “모델”을 타입으로만 두면:

런타임 비용 0

캐시에 넣어도 안전(plain object)

어디서든 자유롭게 변환/조합 가능

반대로 Swift/Kotlin/Dart에서는 “모델”은 런타임에 실제로 존재하는 구조체/클래스야.

Codable, Serializable, Equatable, Hashable

JSON decode/encode

equality/hash

copy/immutability

패턴 매칭

이런 것들이 언어 레벨 기능으로 모델에 붙는 게 일반적임.

2) 모바일은 “런타임 모델 + 직렬화/역직렬화”가 핵심이기 쉬움

모바일은 로컬 저장/오프라인/캐시를 진짜 많이 함:

DB(Room/CoreData)

파일 캐시

앱 재시작 후 복원

background fetch

deep link로 들어온 payload 처리

이때 모델이:

직렬화 가능해야 하고

마이그레이션 고려해야 하고

equality/hash로 diffing 해야 하고

copy해서 수정해야 하고

그래서 Swift struct, Kotlin data class 같은 게 너무 잘 맞아.

웹도 캐시하지만, 보통:

탭 닫으면 끝

세션 단위

storage는 선택

이 차이가 커.

3) UI 프레임워크 철학 차이도 큼 (특히 예전 모바일)
iOS/Android 전통

MVC/MVVM

“Model 객체 + ViewModel이 그것을 조작”

모델에 computed property, formatting, helper method 두는 문화가 강했음

React 세계

“데이터는 plain object”

로직은 함수(리듀서/selector/hook)로 분리

불변 업데이트가 기본

그래서 웹에서는 “모델 = 데이터”, “행동 = 함수들”이 자연스럽고,
모바일은 “모델이 조금 더 똑똑해도 괜찮다”가 자연스러웠던 거지.

(요즘 SwiftUI/Compose는 React랑 닮아가지만, 생태계 관성은 남아있음)

4) 모바일에서 “클래스”가 아니라 사실은 struct/data class가 많다

여기 포인트 중요함.

모바일이 쓰는 건 보통 “OOP 클래스 남발”이 아니라:

Swift: struct (값 타입)

Kotlin: data class (값 중심)

Dart: class지만 보통 불변 + copyWith 패턴

이건 React에서 타입-only 모델을 쓰는 목적(불변/값 중심)과 철학이 꽤 비슷해.

즉 모바일이 “나쁜 구조”라기보다,
값 중심 모델을 언어가 런타임에서 지원하는 방식이 다른 거야.

5) 그럼 “모바일은 언어 한계 때문에 어쩔 수 없이 클래스 쓰는 거냐?”

반은 맞고, 반은 아님.

맞는 부분: TS처럼 “타입만 남기고 런타임 0”이 불가능한 언어가 많음

아닌 부분: 모바일은 런타임 모델이 있으면 생기는 이점이 큼
(직렬화, equality, copy, DB 매핑, 디버깅, 성능 최적화 등)

그래서 모바일에서 모델을 런타임 구조로 두는 건 손해가 아니라 장점일 때가 많아.

6) 웹에서도 “클래스가 더 좋은” 경우가 있긴 해

너가 이미 겪었던 3D/texture 캐싱 같은 거 생각하면 딱임:

수명(lifecycle)이 있고

리소스를 잡고/해제해야 하고

상태 머신이 있고

메서드가 자연스러운 경우

이런 건 웹에서도 클래스가 잘 맞아.

즉 “웹=타입만”이 절대 진리는 아니고,
데이터 스냅샷은 타입/POJO, 상태ful 객체는 클래스가 보통 최적.

결론

모바일이 “언어 한계로 좋지 못한 구조”라고 보긴 어려워.
차라리 이렇게 보는 게 정확해:

웹(React Query 포함)은 ‘캐시/불변/함수 조합’에 최적화된 생태계

모바일은 ‘런타임 모델/직렬화/오프라인/값 타입’에 최적화된 생태계

그래서 모델을 “타입만”으로 둘 수 없는 대신, 언어가 제공하는 struct/data class로 비슷한 목적(값 중심)을 달성한다
