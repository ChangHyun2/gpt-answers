React Query 쓰는 전제면 “에러를 어디서 잡을 수 있나”가 제일 중요해. 결론부터 말하면 에러는 크게 2갈래로 나눠서 설계하는 게 깔끔해.

(A) 화면/컴포넌트 자체가 죽는 에러 → ErrorBoundary가 메인

(B) 데이터/비동기/사용자 액션에서 나는 에러 → React Query onError + try/catch + 전역 핸들러 조합

아래는 네가 말한 4가지 유형을 기준으로 “추천 조합”을 딱 정리해줄게.

1) 컴포넌트 렌더링 과정에서 발생하는 에러 (Render/Lifecycle)

추천: ErrorBoundary + “라우트 단위로 감싸기”

ErrorBoundary는 렌더링 중, 생명주기, 자식 컴포넌트 생성 중 에러를 잡아줌

대신 이벤트 핸들러, setTimeout, Promise, useEffect 내부 async 이런 건 못 잡음

패턴

App 전체에 하나(최후의 보루)

“페이지(라우트) 단위”로 하나씩(사용자 경험 좋음)

위젯/카드처럼 부분 UI도 필요하면 작은 Boundary 추가

<GlobalErrorBoundary>
  <Routes>
    <Route
      path="/orders"
      element={
        <PageErrorBoundary fallback={<OrdersPageFallback />}>
          <OrdersPage />
        </PageErrorBoundary>
      }
    />
  </Routes>
</GlobalErrorBoundary>

2) CRUD 요청 에러 (React Query)

여긴 React Query가 거의 정답을 줘.

(1) 중앙 집중: QueryClient 기본 옵션 onError

추천: “전역 로깅/공통 처리”만 여기서 하고, UI 토스트는 조심(중복 폭탄남)

예: 401이면 로그아웃/리프레시 토큰 플로우

500이면 공통 “일시적 오류” UI

Sentry/Datadog 등 로깅

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: (count, err) => shouldRetry(err, count),
      onError: (err) => {
        reportError(err, { layer: "react-query:query" });
      },
    },
    mutations: {
      onError: (err) => {
        reportError(err, { layer: "react-query:mutation" });
      },
    },
  },
});

(2) 컴포넌트 단위: useQuery/useMutation의 onError / error UI

추천: 유저에게 보여줄 메시지/복구(재시도 버튼 등)는 “여기서”

const mutation = useMutation({
  mutationFn: updateProfile,
  onError: (err) => {
    toast.error(toUserMessage(err));
  },
  onSuccess: () => toast.success("저장 완료"),
});

(3) “정말 강력 추천” 옵션: ErrorBoundary로 쿼리 에러를 넘길지

React Query는 쿼리 에러를 ErrorBoundary로 던지게 할 수 있어(설정/버전별 옵션 이름은 조금 다를 수 있음).

“이 페이지는 데이터 없으면 의미가 없다” → Boundary로 보내고 페이지 fallback 보여주기 👍

“부분 실패여도 페이지는 살아야 한다” → 컴포넌트에서 처리 👍

3) useEffect 에러

핵심: ErrorBoundary가 못 잡는 경우가 많아(특히 async)

추천 패턴

effect 내부를 try/catch로 감싸고

필요하면 “에러 상태”로 바꿔서 UI에 반영

혹은 reportError로만 보내고 조용히 무시(비핵심 효과일 때)

useEffect(() => {
  let cancelled = false;

  (async () => {
    try {
      const data = await something();
      if (!cancelled) setState(data);
    } catch (err) {
      reportError(err, { layer: "useEffect" });
      // 필요하면 setErrorState(err)
    }
  })();

  return () => { cancelled = true; };
}, []);


팁: “데이터 fetch”를 useEffect에서 직접 하지 말고 React Query로 몰아넣는 것 자체가 에러 핸들링을 엄청 단순하게 해줘.

4) 핸들러 함수 에러 (onClick, onSubmit 등)

핵심: 이벤트 핸들러 에러도 ErrorBoundary가 못 잡아. 여기서도 try/catch가 기본.

추천 패턴

동기/비동기 상관없이 핸들러에서 잡아서

사용자 메시지(toast/dialog)

로깅(reportError)

필요시 폼 에러 상태 반영

const onSave = async () => {
  try {
    await mutation.mutateAsync(payload);
  } catch (err) {
    // mutateAsync는 throw 되니까 여기서 통일해서 처리 가능
    toast.error(toUserMessage(err));
    reportError(err, { layer: "handler:onSave" });
  }
};

“중앙 집중 vs 컴포넌트 개별” 추천 설계 (현업에서 제일 덜 삽질하는 구성)
중앙 집중(전역)에서 하는 것

로깅/관측: reportError(err, context) 하나로 통일

인증/권한 공통 처리: 401, 토큰 만료, 강제 로그아웃

치명적 UI fallback: Global ErrorBoundary

unhandled 에러 수집

window.onerror

window.onunhandledrejection

전역에서 “토스트까지” 다 해버리면 중복 알림 지옥이 열릴 확률이 높아서 비추.

컴포넌트(개별)에서 하는 것

사용자에게 보여줄 메시지(문구/행동 유도)

복구 UI: 재시도 버튼, 일부만 fallback

도메인별 예외: “이미 삭제됨”, “재고 없음” 같은 비즈니스 케이스

실전 팁: “에러를 분류하는 함수” 하나 만들면 삶이 편해짐

전역/개별 모두에서 같은 기준으로 처리하려면 최소한 이 3가지는 있으면 좋아:

isAuthError(err) (401/403)

isNetworkError(err) (Failed to fetch 등)

toUserMessage(err) (유저 문구 변환)



흰 화면

1️⃣ Global ErrorBoundary로 해결 가능한 흰 화면
✅ 렌더링 중 throw된 에러
function Profile() {
  // 예: undefined 접근
  return <div>{user.name}</div>;
}


render 중 에러

child 컴포넌트 생성 중 에러

class component lifecycle 에러

👉 Global ErrorBoundary가 있으면

앱 전체가 죽는 대신

fallback UI가 뜸

“하얀 화면” 방지됨

→ 이게 제일 흔한 케이스고, ErrorBoundary 하나만 있어도 체감 개선 큼

2️⃣ Global ErrorBoundary로 못 잡는 흰 화면
❌ (1) 이벤트 핸들러 에러
<button onClick={() => {
  throw new Error("boom");
}}>


클릭 순간 콘솔엔 에러

React 트리 자체는 이미 렌더됨

👉 ErrorBoundary 안 잡힘

❌ (2) useEffect / async 에러
useEffect(() => {
  fetchSomething().then(() => {
    throw new Error("boom");
  });
}, []);


👉 ErrorBoundary 안 잡힘

❌ (3) 초기 JS 로딩 실패

chunk 로딩 실패

네트워크 문제

배포 직후 캐시 꼬임

Loading chunk 12 failed


👉 React가 아예 실행되기 전이라
👉 ErrorBoundary가 존재할 기회조차 없음

❌ (4) 무한 렌더 / 무한 상태 업데이트
useEffect(() => {
  setState(x + 1);
}, [x]);


CPU 100%

화면 갱신 안 됨

👉 ErrorBoundary도 못 살림

3️⃣ 그래서 실전에서 쓰는 “흰 화면 방지 풀세트”
✅ 1. Global ErrorBoundary (무조건)
<GlobalErrorBoundary fallback={<FatalErrorScreen />}>
  <App />
</GlobalErrorBoundary>


이거 없으면 흰 화면 확률 급상승

✅ 2. Route 단위 ErrorBoundary (강추)
<Route
  path="/orders"
  element={
    <RouteErrorBoundary>
      <OrdersPage />
    </RouteErrorBoundary>
  }
/>


특정 페이지 에러 → 앱 전체는 살아있음

UX 체감 확 좋아짐

✅ 3. React Query + ErrorBoundary 연동

“데이터 없으면 의미 없는 페이지”일 때

쿼리 에러를 boundary로 던져서

페이지 fallback으로 전환

👉 데이터 실패 → 하얀 화면 ❌
👉 “문제 발생 / 재시도” 화면 ⭕

✅ 4. chunk 로딩 실패 대응 (이거 진짜 중요)

가끔 뜨는 흰 화면의 진짜 범인

window.addEventListener("error", (e) => {
  if (e.message?.includes("Loading chunk")) {
    window.location.reload();
  }
});


배포 후 가장 효과 좋은 응급처치

Sentry에서도 거의 필수 패턴

✅ 5. 최후의 보루: index.html 레벨 fallback
<div id="root">
  <noscript>JavaScript is required.</noscript>
</div>


로딩 중 스켈레톤/문구
